#include "mmu.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "interrupt.h"

mmu_t g_mmu;

const uint8_t g_internal_rom[0x100] = {
    0x0F, 0x00, 0x7C, 0xFF, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x01, 0x80, 0xBF, 0xF3, 0xFF, 0xBF, 0xFF, 0x3F, 0x00,
    0xFF, 0xBF, 0x7F, 0xFF, 0x9F, 0xFF, 0xBF, 0xFF, 0xFF, 0x00, 0x00, 0xBF,
    0x77, 0xF3, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
    0x00, 0xFF, 0x00, 0xFF, 0x91, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0x7E, 0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0xFF, 0xC1, 0x00,
    0xFE, 0xFF, 0xFF, 0xFF, 0xF8, 0xFF, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCE, 0xED, 0x66, 0x66,
    0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
    0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6,
    0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC,
    0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x45, 0xEC, 0x52, 0xFA,
    0x08, 0xB7, 0x07, 0x5D, 0x01, 0xFD, 0xC0, 0xFF, 0x08, 0xFC, 0x00, 0xE5,
    0x0B, 0xF8, 0xC2, 0xCE, 0xF4, 0xF9, 0x0F, 0x7F, 0x45, 0x6D, 0x3D, 0xFE,
    0x46, 0x97, 0x33, 0x5E, 0x08, 0xEF, 0xF1, 0xFF, 0x86, 0x83, 0x24, 0x74,
    0x12, 0xFC, 0x00, 0x9F, 0xB4, 0xB7, 0x06, 0xD5, 0xD0, 0x7A, 0x00, 0x9E,
    0x04, 0x5F, 0x41, 0x2F, 0x1D, 0x77, 0x36, 0x75, 0x81, 0xAA, 0x70, 0x3A,
    0x98, 0xD1, 0x71, 0x02, 0x4D, 0x01, 0xC1, 0xFF, 0x0D, 0x00, 0xD3, 0x05,
    0xF9, 0x00, 0x0B, 0x00};

static int load_rom(const char *path, uint8_t *buffer, size_t bufsize)
{
    FILE *file = fopen(path, "rb");
    if (file == NULL) {
        return -1;
    }
    /* Get file size. */
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    if (size > bufsize) {
        fclose(file);
        fprintf(stderr, "ERROR: rom too big!\n");
        return -1;
    }
    rewind(file);
    /* Read rom to memory. */
    size_t read_size = fread(buffer, 1, size, file);
    fclose(file);
    if (read_size != size) {
        fprintf(stderr, "ERROR: fread\n");
        return -1;
    }
    return 0;
}

int mmu_init(const char *rom_path)
{
    int ret = load_rom(rom_path, g_mmu.rom, sizeof(g_mmu.rom));
    if (ret < 0) {
        return -1;
    }
    memset(g_mmu.sram, 0, sizeof(g_mmu.sram));
    // memcpy(g_mmu.io, io_reset, sizeof(g_mmu.io));
    memset(g_mmu.vram, 0, sizeof(g_mmu.vram));
    memset(g_mmu.oam, 0, sizeof(g_mmu.oam));
    memset(g_mmu.wram, 0, sizeof(g_mmu.wram));
    memset(g_mmu.hram, 0, sizeof(g_mmu.hram));
    g_mmu.read_internal_rom = true;
    interrupt_init();
    return 0;
}

/* Read 8-bit byte from a given address */
uint8_t mmu_read_byte(uint16_t addr)
{
    switch (addr & 0xf000) {
        case 0x0000:
            /* 256 B Internal ROM accessed after reset. */
            if (g_mmu.read_internal_rom) {
                if (addr < 0x0100)
                    return g_internal_rom[addr];
                else if (addr == 0x0100)
                    g_mmu.read_internal_rom = false;
            }
        /* Fall through! */

        /* 16kB ROM bank #0. */
        case 0x1000:
        case 0x2000:
        case 0x3000:

        /* 16kB Switchable ROM bank. */
        case 0x4000:
        case 0x5000:
        case 0x6000:
        case 0x7000:
            return g_mmu.rom[addr];

        /* 8kB Video RAM. */
        case 0x8000:
        case 0x9000:
            return g_mmu.vram[addr & 0x1fff];

        /* 8kB Switchable RAM bank. */
        case 0xa000:
        case 0xb000:
            return g_mmu.sram[addr & 0x1fff];

        /* 8kB Internal RAM. */
        case 0xc000:
        case 0xd000:
            return g_mmu.wram[addr & 0x1fff];

        case 0xe000:
        case 0xf000:
            /* Echo of 8kB Internal RAM; */
            if (addr < 0xfe00) {
                return g_mmu.wram[addr & 0x1fff];
            }
            switch (addr & 0x0f00) {
                case 0xe00:
                    /* Sprite Attrib Memory (OAM). */
                    if ((addr & 0xff) < 0xa0) {
                        return g_mmu.oam[addr & 0xff];
                    } else {
                        /* Remaining bytes read as 0. */
                        return 0;
                    }

                case 0xf00:
                    if (addr < 0xff80) {
                        /* I/O ports. */
                        fprintf(stderr, "ERROR: I/O not implemented!\n");
                        // return g_mmu.io[addr & 0x7f];
                        return 0;
                    } else if (addr < 0xfffe) {
                        /* Internal RAM. */
                        return g_mmu.hram[addr - 0xff80];
                    } else {
                        /* Interrupt Enable Register. */
                        return interrupt_get_enable();
                    }
            }
    }
    fprintf(stderr, "ERROR: shouldn't execute this!\n");
    return 0;
}

uint16_t mmu_read_word(uint16_t addr)
{
    return mmu_read_byte(addr + 1) << 8 | mmu_read_byte(addr);
}

void mmu_write_byte(uint16_t addr, uint8_t value)
{
}

void mmu_write_word(uint16_t addr, uint16_t value)
{
}
